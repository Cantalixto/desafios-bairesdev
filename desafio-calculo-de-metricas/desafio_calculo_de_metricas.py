# -*- coding: utf-8 -*-
"""desafio-calculo-de-metricas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SS4lr87PZ3oQIoRPjXTuEDR7e3r-AwuD

Desafio de cálculo de métricas usando apenas funções no python para o bootcamp da BairesDev / Dio.me
"""

# Importa as bibliotecas e os dados necessários

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.datasets import load_breast_cancer

# Carrega o dataset de câncer de mama

cancer_dataset = load_breast_cancer()

x = cancer_dataset.data # Características
y = cancer_dataset.target # Rótulos ( 0 = benigno, 1 = maligno)

# Divide o dataset em treino e teste ( 20% para teste)

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Cria e treina o modelo de regressão logísitica

model = LogisticRegression(max_iter=5000)
model.fit(x_train, y_train)

# Faz as previsões no conjunto de teste

y_pred = model.predict(x_test)

# Funções para cálculo de métricas

def calcular_metricas(y_test, y_pred):
  """ Retorna VP, VN, FP, FN, acurácia, precisão, revocação e F1-score"""

  # Inicializa os contadores
  VP = 0 #verdadeiro positivo
  VN = 0 #verdadeiro negativo
  FP = 0 #falso positivo
  FN = 0 #falso negativo

  # Compara os rótulos reais com as previsões
  for i in range(len(y_test)):
    if y_test[i] == 1 and y_pred[i] == 1:
      VP += 1
    elif y_test[i] == 0 and y_pred[i] == 0:
      VN += 1
    elif y_test[i] == 0 and y_pred[i] == 1:
      FP += 1
    elif y_test[i] == 1 and y_pred[i] == 0:
      FN += 1

  # Calcula as métricas usando os contadores
  total = VP + VN + FP + FN
  acuracia = (VP + VN) / total if total > 0 else 0
  precisao = VP / (VP + FP) if (VP + FP) > 0 else 0
  revocacao = VP / (VP + FN) if (VP + FN) > 0 else 0
  f1_score = 2 * (precisao * revocacao) / (precisao + revocacao) if (precisao + revocacao) > 0 else 0

  return VP, VN, FP, FN, acuracia, precisao, revocacao, f1_score

# Plota matriz de confusão

def plotar_matriz_confusao(cm, classes, titulo = 'Matriz de Confusão'):
  plt.figure(figsize=(8, 6))
  sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)
  plt.xlabel('Predição')
  plt.ylabel('Valor Real')
  plt.title(titulo)
  plt.show()

#  ---Avaliação completa do modelo---

# Calcula todos os valores e métricas manualmente
VP, VN, FP, FN, acuracia, precisao, revocacao, f1_score = calcular_metricas(y_test, y_pred)

# Imprimi os resultados dos contadores
print(f"---Contagem Manual da Matriz de Confusão---\n")
print(f"Verdadeiros Positivos (VP): {VP}")
print(f"Verdadeiros Negativos (VN): {VN}")
print(f"Falsos Positivos (FP): {FP}")
print(f"Falsos Negativos (FN): {FN}")

# Imprimi as métricas calculadas
print(f"\n---Métricas de Avaliação---\n")
print(f"Acurácia: {acuracia:.4f}")
print(f"Precisão: {precisao:.4f}")
print(f"Revocação: {revocacao:.4f}")
print(f"F1-Score: {f1_score:.4f}")

# Gera a matriz de confusão com os valores da contagem
cm = np.array([[VN, FP], [FN, VP]])

# Plota a matriz de confusão
rotulos_classes = ['Benigno', 'Maligno']
plotar_matriz_confusao(cm, rotulos_classes, titulo='Matriz de Confusão')